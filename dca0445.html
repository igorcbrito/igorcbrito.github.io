<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content=S"width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Página pessoal - Igor Brito</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/resume.min.css" rel="stylesheet">

  <style>
    img {
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    </style>

</head>

<body id="page-top">

  <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
    <a class="navbar-brand js-scroll-trigger" href="#page-top">
      <span class="d-block d-lg-none">Igor Brito</span>
      <span class="d-none d-lg-block">
        <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="img/profile.jpg" alt="">
      </span>
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#dca0445">Igor Brito</a>
        </li>
      </ul>
    </div>
    <a class="navbar-brand js-scroll-trigger" href="#page-top">
      <span class="d-none d-lg-block">
        <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="img/imgMicael.jpg" alt="">
      </span>
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#dca0445">Micael Balza</a>
        </li>
      </ul>
    </div>
  </nav>

  <div class="container-fluid p-0">

    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="dca0445">
      <div class="w-100">
        <h2 class="mb-5">DCA0445 - Igor Brito e Micael Balza</h2>  

         <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
          <div class="resume-content">
            <h3 class="mb-0">Exercício 2.2.1 </h3>
            <p>O objetivo deste exercício consiste em pegar dois pontos inseridos pelo usuário, desde que sejam dentro das dimensões da imagem selecionada, e com base nesses dois pontos formar uma área retangular com tons invertidos (negativo). Para construir o programa, foi utilizado como base o código pixels.cpp cedido pelo professor.

              Inicialmente, foi utilizado uma estrutura de dado de par para representar os pontos P1 e P2 e também suas coordenadas. Após lidas as posições x e y de cada um dos pontos, foi criada uma validação para que se garanta que o programa não funcione com pontos inválidos, como valores negativos e também coordenadas que estejam fora da figura escolhida.
              
              Para criar a área negativa, bastou-se alterar o preenchecimento dos pixels dentro da área demarcada pelos pontos P1 e P2 por seus valores multiplicados por -1.</p>
          </div>
        </div>
	      
	<div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
          <div class="resume-content">
            <h3 class="mb-0">Exercício 2.2.2 </h3>
            <p>Explorando algumas caracteristicas, temos que biel.png é uma imagem em tons de cinza, com dimensão quadrada de 256*256 ... EM CONSTRUÇAO</p>
          </div>
        </div>
       
       <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
        <div class="resume-content">
          <h3 class="mb-0">Exercício 3.2.1</h3>
          <p>Caso existam mais de 255 objetos na cena, o processo de rotulação estará comprometido devido ao uso do tipo de dado como uchar, esse tipo é um char sem sinal, que representa com 8 bits valores de 0 a 255. Como a rotulação usa a representação de cor(tons de cinza) como ferramenta para distinguir os objetos na cena, caso o número seja maior que 255 não se pode garantir a correta rotulação.
              Uma forma de resolver este problema é mudar o tipo de dado usado para representar a cor, se por exemplo utilizarmos um unsigned int de 32 bits que representa valores de 0 a 65.535, aumentamos significativamente a capacidade de rotular mais objetos na imagem.</p>
        </div>
      </div>
        
            <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
        <div class="resume-content">
          <h3 class="mb-0">Exercício 3.2.2</h3>
          <p>Podemos dividir a resolução desse problema em 3 partes principais:<br>
		&#x2192; Remoção das bolhas que tocam nas bordas<br>
		&#x2192; Rotulação das bolhas<br>
		&#x2192; Contagem de buracos<br> </p>
		A imagem é composta por um fundo preto representado pelo valor 0, e bolhas brancas representadas pelo valor 255.<br><br>
		<img src="dca0445-images/bolhas.png"
                class="center"
                width="256"
                height="256">
		O trecho abaixo foi usado para percorrer as bordas da imagem, fixando o X e percorrendo o Y, varremos a borda direita e esquerda da imagem. A mesma lógica é seguida para percorrer as bordas superior e inferior, só que desta vez fixando o Y e percorrendo o X. Ao varrer as bordas da imagem e encontrando valores iguais a 255, encontramos uma bolha e que ela se encontra na borda, para apagar foi chamado a função <code>floodFill</code> pintando a cor de fundo.
			<pre><code> 
			  // excluir objetos das bordas
			  // percorrer as bordas e execultar o floodfill, quando achar uma bolha que esta na bordar colorir com o fundo
			  nobjects=0;
			  for(int i=0; i<height; i++){ // percorrendo as linhas ( o y) 
			    if(image.at<uchar>(i,0) == 255){
				// achou um objeto
				p.x=0;
				p.y=i;
			  		// preenche o objeto com a cor de fundo
					  cv::floodFill(image,p,0);
			    } 
			    if(image.at<uchar>(i,height-1) == 255){
				// achou um objeto
				p.x=height-1;
				p.y=i;
			  		// preenche o objeto com a cor de fundo
					  cv::floodFill(image,p,0);
			    }  
			  } 
			  for(int j=0; j<width; j++){
			    if(image.at<uchar>(0,j) == 255){
				// achou um objeto
				p.x=j;
				p.y=0;
			  		// preenche o objeto com a cor de fundo
					  cv::floodFill(image,p,0);
			    }
			    if(image.at<uchar>(width-1,j) == 255){
				// achou um objeto
				p.x=j;
				p.y=width-1;
			  		// preenche o objeto com a cor de fundo
					  cv::floodFill(image,p,0);
			    }  
			  }
			</code>
			</pre>	

			<img src="dca0445-images/labeling-edges.png"
		        class="center"
		        width="256"
		        height="256">
			
			Foi feito a contagem e rotulação das bolhas em tons de cinza usando a função <code>floodFill</code>, acrescentando 1 tom a mais para cada valor, ao final o contador será igual a cor da ultima bolha.
			<img src="dca0445-images/labeling_gray.png"
		        class="center"
		        width="256"
		        height="256">
			Na etapa final o programa vai pintar a cor de fundo de branco, se diferenciando dos buracos em preto e das bolhas em cinza, dessa forma percorre-se a imagem em busta cos valores iguais a 0(buraco),um teste condicional é usado para garantir que uma bolha com 2 ou mais buracos não seja contada duas vezes. Ao final pinta-se de branco as bolhas já contadas com buraco, restando somente as sem buraco. O valor das contagens é feito subtraindo o total de bolhas das bolhas com buraco.
			<pre><code>
			  // Agora pintamos o fundo da imagem, de outra cor
			  // Pintando de branco, o fundo vai se diferenciar dos buracos(preto), e das bolhas(cinza)
			  // O ponto 0,0 faz parte do fundo
			  p.x=0;
			  p.y=0;
			  cv::floodFill(image,p,255);

			  // Com o fundo branco podemos percorrer a imagem procurando buracos(pretos), e realizar a contagem.
			  int bolhas = 0;
			  for(int i=0; i<height; i++){
			    for(int j=0; j<width; j++){
			      if((int)image.at<uchar>(i,j) == 0 && (int)image.at<uchar>(i,j-1) != 255){
				bolhas++;
				p.x=j;
				p.y=i;
				cv::floodFill(image,p,255);
				p.x=j-1;
				p.y=i;
				cv::floodFill(image,p,255);
			      }
			      else if((int)image.at<uchar>(i,j) == 0){
				std::cout << "1pizza2";
				p.x=j;
				p.y=i;
				floodFill(image,p,255);
			      }
			    }  
			  }
			</code></pre>	
			<img src="dca0445-images/ex3.2"
		        class="center"
		        width="250"
		        height="74">
 		
        </div>
      </div>


      <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
        <div class="resume-content">
          <h3 class="mb-0">Exercício 4.2.1</h3>
          <p>Neste exercício, foi proposto a realização de uma equalização em um vídeo capturado pela webcam do computador em tempo real, considerando o processamento das imagens em tons de cinza.

            Sendo assim, foi tomado como base o código presente no arquivo histogram.cpp e após a captura das imagens pela webcam, foi feito uma conversão de cores da fonte de imagem para uma escala de tons de cinza utilizando a função cvtColor(image, imageGrayscale, cv::COLOR_RGB2GRAY, 0); do opencv.
            
            Logo em seguida, foi utilizada a função equalizeHist(imageGrayscale, imageGrayscale); que realiza a equalização do histograma da imagem.
            Vale salientar que todo o processamento feito nas imagens ocorreu quadro a quadro do vídeo.
            
            Como resultado, nota-se um aumento no contraste da imagem, mas que em algumas situações causa o efeito de falso contorno, como na imagem abaixo.
            
            Repare, que durante a transição de uma cena escura para uma clara, é produzido um contorno no fundo da imagem que não existe, de fato.</p>

            <img src="dca0445-images/4.2.1.jpeg"
                class="center"
                width="441"
                height="312">
        </div>
      </div>

    </section>

    <hr class="m-0">

  </div>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/resume.min.js"></script>

</body>

</html>
