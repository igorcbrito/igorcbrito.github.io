<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content=S"width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Página pessoal - Igor Brito</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/resume.min.css" rel="stylesheet">

  <style>
    img {
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    </style>

</head>

<body id="page-top">

  <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
    <a class="navbar-brand js-scroll-trigger" href="#page-top">
      <span class="d-block d-lg-none">Igor Brito</span>
      <span class="d-none d-lg-block">
        <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="img/profile.jpg" alt="">
      </span>
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#dca0445">Igor Brito</a>
        </li>
      </ul>
    </div>
    <a class="navbar-brand js-scroll-trigger" href="#page-top">
      <span class="d-none d-lg-block">
        <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="img/imgMicael.jpg" alt="">
      </span>
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#dca0445">Micael Balza</a>
        </li>
      </ul>
    </div>
  </nav>

  <div class="container-fluid p-0">

    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="dca0445">
      <div class="w-100">
        <h2 class="mb-5">DCA0445 - Igor Brito e Micael Balza</h2>  

         <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
          <div class="resume-content">
            <h3 class="mb-0">Exercício 2.2.1 </h3>
            <p>O objetivo deste exercício consiste em pegar dois pontos inseridos pelo usuário, desde que sejam dentro das dimensões da imagem selecionada, e com base nesses dois pontos formar uma área retangular com tons invertidos (negativo). Para construir o programa, foi utilizado como base o código pixels.cpp cedido pelo professor.

              Inicialmente, foi utilizado uma estrutura de dado de par para representar os pontos P1 e P2 e também suas coordenadas. Após lidas as posições x e y de cada um dos pontos, foi criada uma validação para que se garanta que o programa não funcione com pontos inválidos, como valores negativos e também coordenadas que estejam fora da figura escolhida.
              
              Para criar a área negativa, bastou-se alterar o preenchecimento dos pixels dentro da área demarcada pelos pontos P1 e P2 por seus valores multiplicados por -1.</p>
              <img src="dca0445-images/pikachu-negativo.png"
                class="center"
                width="504"
                height="191">
            </div>
        </div>
	      
        <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
          <div class="resume-content">
            <h3 class="mb-0">Exercício 2.2.2 </h3>
            <p>O objetivo deste exercício consistem em realizar a troca dos quadrantes nas diagonais de uma figura. O código usado como base para criação do programa foi o pixels.cpp, onde foi realizada a criação de 
              novas variáveis matriciais no tamanho exato de cada quadrante quadrante da figura. Após a criação das matrizes que representam os quadrantes, foram utilizadas estruturas 
              de loop for para copiar cada pixel de cada quadrante para as matrizes correspondentes. Em seguida foram utilizados outros loops para criar a nova imagem completa, 
              substituindo com a ajuda de deslocamentos na variável de iteração do loop, os quadrantes. Resumindo, a imagem escolhida 
              foi separada em quatro imagens menores, uma com cada quadrante da imagem original. Em seguida, uma nova imagem foi preenchida realizando a troca dos quadrantes nas diagonais.</p>
          </div>
        </div>

       
       <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
        <div class="resume-content">
          <h3 class="mb-0">Exercício 3.2.1</h3>
          <p>Caso existam mais de 255 objetos na cena, o processo de rotulação estará comprometido devido ao uso do tipo de dado como uchar, esse tipo é um char sem sinal, que representa com 8 bits valores de 0 a 255. Como a rotulação usa a representação de cor(tons de cinza) como ferramenta para distinguir os objetos na cena, caso o número seja maior que 255 não se pode garantir a correta rotulação.
              Uma forma de resolver este problema é mudar o tipo de dado usado para representar a cor, se por exemplo utilizarmos um unsigned int de 32 bits que representa valores de 0 a 65.535, aumentamos significativamente a capacidade de rotular mais objetos na imagem.</p>
        </div>
      </div>
        
      <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
        <div class="resume-content">
          <h3 class="mb-0">Exercício 3.2.2</h3>
          <p>Podemos dividir a resolução desse problema em 3 partes principais:<br>
		&#x2192; Remoção das bolhas que tocam nas bordas<br>
		&#x2192; Rotulação das bolhas<br>
		&#x2192; Contagem de buracos<br> </p>
		A imagem é composta por um fundo preto representado pelo valor 0, e bolhas brancas representadas pelo valor 255.<br><br>
		<img src="dca0445-images/bolhas.png"
                class="center"
                width="256"
                height="256">
		O trecho abaixo foi usado para percorrer as bordas da imagem, fixando o X e percorrendo o Y, varremos a borda direita e esquerda da imagem. A mesma lógica é seguida para percorrer as bordas superior e inferior, só que desta vez fixando o Y e percorrendo o X. Ao varrer as bordas da imagem e encontrando valores iguais a 255, encontramos uma bolha e que ela se encontra na borda, para apagar foi chamado a função <code>floodFill</code> pintando a cor de fundo.
			<pre><code> 
			  // excluir objetos das bordas
			  // percorrer as bordas e execultar o floodfill, quando achar uma bolha que esta na bordar colorir com o fundo
			  nobjects=0;
			  for(int i=0; i<height; i++){ // percorrendo as linhas ( o y) 
			    if(image.at<uchar>(i,0) == 255){
				// achou um objeto
				p.x=0;
				p.y=i;
			  		// preenche o objeto com a cor de fundo
					  cv::floodFill(image,p,0);
			    } 
			    if(image.at<uchar>(i,height-1) == 255){
				// achou um objeto
				p.x=height-1;
				p.y=i;
			  		// preenche o objeto com a cor de fundo
					  cv::floodFill(image,p,0);
			    }  
			  } 
			  for(int j=0; j<width; j++){
			    if(image.at<uchar>(0,j) == 255){
				// achou um objeto
				p.x=j;
				p.y=0;
			  		// preenche o objeto com a cor de fundo
					  cv::floodFill(image,p,0);
			    }
			    if(image.at<uchar>(width-1,j) == 255){
				// achou um objeto
				p.x=j;
				p.y=width-1;
			  		// preenche o objeto com a cor de fundo
					  cv::floodFill(image,p,0);
			    }  
			  }
			</code>
			</pre>	

			<img src="dca0445-images/labeling-edges.png"
		        class="center"
		        width="256"
		        height="256">
			
			Foi feito a contagem e rotulação das bolhas em tons de cinza usando a função <code>floodFill</code>, acrescentando 1 tom a mais para cada valor, ao final o contador será igual a cor da ultima bolha.
			<img src="dca0445-images/labeling_gray.png"
		        class="center"
		        width="256"
		        height="256">
			Na etapa final o programa vai pintar a cor de fundo de branco, se diferenciando dos buracos em preto e das bolhas em cinza, dessa forma percorre-se a imagem em busta cos valores iguais a 0(buraco),um teste condicional é usado para garantir que uma bolha com 2 ou mais buracos não seja contada duas vezes. Ao final pinta-se de branco as bolhas já contadas com buraco, restando somente as sem buraco. O valor das contagens é feito subtraindo o total de bolhas das bolhas com buraco.
			<pre><code>
			  // Agora pintamos o fundo da imagem, de outra cor
			  // Pintando de branco, o fundo vai se diferenciar dos buracos(preto), e das bolhas(cinza)
			  // O ponto 0,0 faz parte do fundo
			  p.x=0;
			  p.y=0;
			  cv::floodFill(image,p,255);

			  // Com o fundo branco podemos percorrer a imagem procurando buracos(pretos), e realizar a contagem.
			  int bolhas = 0;
			  for(int i=0; i<height; i++){
			    for(int j=0; j<width; j++){
			      if((int)image.at<uchar>(i,j) == 0 && (int)image.at<uchar>(i,j-1) != 255){
				bolhas++;
				p.x=j;
				p.y=i;
				cv::floodFill(image,p,255);
				p.x=j-1;
				p.y=i;
				cv::floodFill(image,p,255);
			      }
			      else if((int)image.at<uchar>(i,j) == 0){
				std::cout << "1pizza2";
				p.x=j;
				p.y=i;
				floodFill(image,p,255);
			      }
			    }  
			  }
			</code></pre>	
			<img src="dca0445-images/ex3.2"
		        class="center"
		        width="250"
		        height="74">
 		
        </div>
      </div>


      <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
        <div class="resume-content">
          <h3 class="mb-0">Exercício 4.2.1</h3>
          <p>Neste exercício, foi proposto a realização de uma equalização em um vídeo capturado pela webcam do computador em tempo real, considerando o processamento das imagens em tons de cinza.

            Sendo assim, foi tomado como base o código presente no arquivo histogram.cpp e após a captura das imagens pela webcam, foi feito uma conversão de cores da fonte de imagem para uma escala de tons de cinza utilizando a função cvtColor(image, imageGrayscale, cv::COLOR_RGB2GRAY, 0); do opencv.
            
            Logo em seguida, foi utilizada a função equalizeHist(imageGrayscale, imageGrayscale); que realiza a equalização do histograma da imagem.
            Vale salientar que todo o processamento feito nas imagens ocorreu quadro a quadro do vídeo.
            
            Como resultado, nota-se um aumento no contraste da imagem, mas que em algumas situações causa o efeito de falso contorno, como na imagem abaixo.
            
            Repare, que durante a transição de uma cena escura para uma clara, é produzido um contorno no fundo da imagem que não existe, de fato.</p>

            <img src="dca0445-images/4.2.1.jpeg"
                class="center"
                width="441"
                height="312">
        </div>
      </div>


      <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
        <div class="resume-content">
          <h3 class="mb-0">Exercício 4.2.2</h3>
          <p>Utilizando o programa exemplos/histogram.cpp como referência disponível no site <a href="https://agostinhobritojr.github.io/tutorial/pdi/#_exerc%C3%ADcios_3">Introdução ao processamento digital de imagens com OpenCV</a> </p>
            de Agostinho Brito, modificamos o código para implementar um detector de movimento por meio do histograma.
            Alguns pontos importantes podem ser descritos:
            &#x2192; O histograma calcula o número de ocorrências de determinada cor.<br>
            &#x2192; Foi escolhido então a componente da cor azul, uma componente só é suficiente para detectar o movimento<br>
            &#x2192; Ao detectar um movimento o programa deve avisar.<br>

            Desta forma a implementação usou o código que calculava o histograma de um video, frame a frame e atualizava o valor plotando o histograma,
            foi implementado uma etapa de calibração que apartir do frame inicial + 1, calculava para o canal azul e salvava na variável <code>calibration_threshold</code> o menor valor dos 100 primeiros frames,
            depois um fator de segurança de 95% diminuia ainda mais esse limiar.
            Esta etapa de calibraçãose dá por conta do ruído existente na captura da imagem pela câmera, se o valor for muito pequeno pode existir uma falsa detecção de movimento.

            Após ser calibrado o programa continua em loop, comparando o valor do histograma do frame atual com o valor do frame passado, se essa comparação for maior que <code>calibration_threshold</code>, foi detectado movimento.
            Ultilizamos a função <code> compareHist(histB, oldHist, cv::HISTCMP_CORREL)</code>, de forma que a comparação seja feita pela correlação entre os histogramas, retornando valores entre 0 e 1, com o primeiro para totalmente diferentes e o segundo para iguais.
            O trecho abaixo refere-se como foi implementado esta parte de detecção:
            <pre><code> 
              // Vamos usar o canal azul para identificar o movimento
              // Apenas uma componente de cor é suficiente
              // primeiro capturamos a imagem estática para calibrar o programa, pois devido ao ruído da câmera podemos ter 'falsa detecção'
          
              // calibração --> as primeiras 100 imagens serão usadas para calibrar
              
              if(firstImage==true){
                std::cout << std::endl << std::endl;
                std::cout << "Deixe a camera estática para calibração  " << std::endl;
                std::cout << "As primeiras 100 imagens serão usadas  " << std::endl;
              }
          
              if(firstImage == false){
                hist_comp = compareHist(histB, oldHist, cv::HISTCMP_CORREL);
                  if(cont<100){
                    if(calibration_threshold > hist_comp)  calibration_threshold = hist_comp;
                    cont++;
                    if(cont == 100){
                      calibration_threshold = calibration_threshold * 0.95; // 95% --> safety margin
                      std::cout << "Calibrado com limiar de: "<< calibration_threshold << std::endl;
                    }
                  }else{
                    if( hist_comp < calibration_threshold){
                        std::cout << "MOVIMENTO DETECTADO!!!  \a" << std::endl;
                    }
                  }
                  
              }
            </pre></code> 
            <img src="dca0445-images/tesla.gif" alt="850"  width="500" />
            
        </div>
      </div>


      <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
        <div class="resume-content">
          <h3 class="mb-0">Exercício 5.2</h3>
          <p>Neste exercício, foi pedido que se adicione um novo tipo de filtragem espacial, o filtro laplaciano do gaussiano. Como o nome sugere, o 
            filtro antes de aplicar a detecção de bordas laplaciana, realiza uma suaviação de por meio do filtro gaussiano a fim de atenuar ruídos que podem atrapalhar na detecção de bordas.

            O kernel, ou máscara, utilizada na filtragem é representada por uma matriz 5x5 originada a partir da expressão abaixo.
            
            As adaptações necessárias no código addwheited.cpp cedido pelo professor, consistem na adição da matriz do filtro laplaciano 
            do gaussiano e também em uma nova opção do switch case para selecionar a aplicação do filtro. Ao apertar 'x' o usuário pode verificar o resultado como o obtido abaixo.</p>

        </div>
      </div>

    </section>

    <hr class="m-0">

  </div>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/resume.min.js"></script>

</body>

</html>
